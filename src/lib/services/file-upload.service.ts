import { type AssignmentFile } from "@/types/file";
import { debugAPI } from "@/lib/utils/debug.service";
import { getFileTypeCategory } from "@/lib/utils/file-type.utils";
import { StorageService } from "@/lib/services/storage.service";
import { DatabaseService, DatabaseVerificationService } from "@/lib/services/database.service";
import { AuthService } from "@/lib/services/auth.service";

// Define a type for creating a new file record (without id since it's generated by DB)
type NewAssignmentFile = Omit<AssignmentFile, 'id'>;

/**
 * Create a file record for database insertion
 */
function createFileRecord(
  userId: string, 
  assignmentId: string | undefined, 
  fileName: string, 
  fileUrl: string, 
  fileType: string, 
  fileSize: number
): NewAssignmentFile {
  const timestamp = new Date().toISOString();
  
  return {
    student_id: userId,
    assignment_id: assignmentId || null,
    file_url: fileUrl,
    file_name: fileName,
    file_type: getFileTypeCategory(fileType),
    file_size: fileSize,
    created_at: timestamp,
    updated_at: timestamp
  };
}

/**
 * Upload multiple files and create database records
 */
export async function handleFileUpload(files: FileList, assignment_id?: string): Promise<AssignmentFile[]> {
  debugAPI.step('Starting file upload process', { 
    filesCount: files.length, 
    assignment_id 
  });
  
  // Get and verify user
  const user = await AuthService.getCurrentUser();
  
  // Verify database table
  const tableExists = await DatabaseVerificationService.verifyTableExists("assignment_files");
  if (!tableExists) {
    const error = new Error("Assignment files table does not exist or is not accessible");
    debugAPI.error("Table verification failed", error);
    throw error;
  }
  
  const uploadedFiles: AssignmentFile[] = [];
  
  // Process each file
  for (const file of Array.from(files)) {
    let filePath = "";
    
    try {
      // 1. Upload file to storage
      filePath = await StorageService.uploadFile(file);
      
      // 2. Get public URL
      const publicUrl = StorageService.getPublicFileUrl(filePath);
      
      // 3. Create file record
      const fileRecord = createFileRecord(
        user.id, 
        assignment_id, 
        file.name, 
        publicUrl, 
        file.type, 
        file.size
      );
      
      // 4. Insert into database
      try {
        // Type assertion for fileRecord as it's correctly shaped but TS doesn't recognize it
        const { data, error } = await DatabaseService.insertRecord('assignment_files', fileRecord as unknown as Record<string, unknown>);
        
        if (error || !data) {
          // Clean up storage file if database insert fails
          await StorageService.deleteFile(filePath);
          debugAPI.error('Database insertion failed', error);
          throw error || new Error("Failed to create file record");
        }
        
        uploadedFiles.push(data as unknown as AssignmentFile);
      } catch (dbError) {
        // Clean up storage file if database insert fails
        await StorageService.deleteFile(filePath);
        throw dbError;
      }
      
    } catch (error) {
      debugAPI.error('File processing failed', error);
      throw error;
    }
  }

  debugAPI.step('Upload process completed', { 
    filesProcessed: uploadedFiles.length 
  });
  return uploadedFiles;
}

/**
 * Get files associated with an assignment
 */
export async function getAssignmentFiles(assignment_id: string): Promise<AssignmentFile[]> {
  try {
    debugAPI.step('Starting file retrieval', { assignment_id });
    
    // For debugging, verify the user is authenticated
    await AuthService.getCurrentUser();
    
    // Query files from database
    const { data, error } = await DatabaseService.queryRecords(
      "assignment_files",
      { assignment_id },
      { orderBy: "created_at", ascending: false }
    );

    if (error || !data) {
      debugAPI.error('File query failed', error);
      throw error || new Error("Failed to retrieve files");
    }

    debugAPI.info('Files retrieved successfully', { 
      fileCount: data.length,
      files: data 
    });
    
    return data as AssignmentFile[];
  } catch (error) {
    debugAPI.error('File retrieval failed', error);
    throw error;
  }
}

/**
 * Delete a file from storage and database
 */
export async function deleteAssignmentFile(fileId: string, fileUrl: string): Promise<void> {
  try {
    debugAPI.step('Starting file deletion', { fileId, fileUrl });
    
    // 1. Delete from storage
    const filePath = fileUrl.split("/").pop(); // Get filename from URL
    if (filePath) {
      await StorageService.deleteFile(filePath);
    }

    // 2. Delete from assignment_files table
    debugAPI.step('Deleting database record', { fileId });
    const { success, error } = await DatabaseService.deleteRecord("assignment_files", fileId);

    if (!success) {
      debugAPI.error('Database record deletion failed', error);
      throw error || new Error("Failed to delete file record");
    }

    debugAPI.info('File record deleted successfully');
    debugAPI.step('Deletion process completed');
    
  } catch (error) {
    debugAPI.error('File deletion failed', error);
    throw error;
  }
}

/**
 * Diagnose issues with file storage and database
 */
export async function diagnoseFileIssues(): Promise<{
  tableExists: boolean;
  recordCount: number;
  storageAccessible: boolean;
}> {
  try {
    debugAPI.step('Diagnosing potential file system issues');
    
    // 1. Check if tables exist and are accessible
    const tableExists = await DatabaseVerificationService.verifyTableExists('assignment_files');
    
    // 2. Count records
    const recordCount = tableExists 
      ? await DatabaseVerificationService.countRecords('assignment_files')
      : 0;
    
    // 3. Check storage access
    let storageAccessible = false;
    try {
      await StorageService.listFiles();
      storageAccessible = true;
    } catch (error) {
      debugAPI.error('Storage access check failed', error);
    }
    
    const result = { tableExists, recordCount, storageAccessible };
    debugAPI.info('Diagnostics completed', result);
    return result;
      
  } catch (error) {
    debugAPI.error('Diagnostics failed', error);
    return {
      tableExists: false,
      recordCount: 0,
      storageAccessible: false
    };
  }
} 