import { type AssignmentFile } from "@/types/file";
import { supabase } from "@/integrations/supabase/client";
import { debugAPI } from "@/lib/utils/debug.service";
import { getFileTypeCategory } from "@/lib/utils/file-type.utils";

// Define a type for creating a new file record (without id since it's generated by DB)
type NewAssignmentFile = Omit<AssignmentFile, 'id'>;

type DatabaseError = {
  message: string;
  code?: string;
  details?: string;
};

type DatabaseResponse<T> = {
  exists: boolean;
  data: T | null;
  error: DatabaseError | null;
};

// Database verification service
const DatabaseVerificationService = {
  async verifyRecord<T>(table: string, id: string): Promise<DatabaseResponse<T>> {
    try {
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .eq('id', id)
        .single();

      debugAPI.info('Record verification result', { data, error });
      
      return {
        exists: !!data,
        data: data as T,
        error: error as DatabaseError
      };
    } catch (error) {
      const dbError = error as DatabaseError;
      debugAPI.error('Record verification failed', dbError);
      return { exists: false, data: null, error: dbError };
    }
  },

  async countRecords(table: string): Promise<number> {
    try {
      const { count, error } = await supabase
        .from(table)
        .select('*', { count: 'exact', head: true });

      debugAPI.info('Table record count', { count, error });
      
      return count || 0;
    } catch (error) {
      const dbError = error as DatabaseError;
      debugAPI.error('Count records failed', dbError);
      return 0;
    }
  }
};

// Database operations service
const DatabaseService = {
  async insertRecord<T>(table: string, data: T): Promise<{ data: T | null; error: DatabaseError | null }> {
    try {
      debugAPI.step(`Starting ${table} record insertion`, data);

      const { data: insertedData, error } = await supabase
        .from(table)
        .insert([data])
        .select()
        .single();

      if (error) {
        debugAPI.error(`${table} insertion failed`, error as DatabaseError);
        return { data: null, error: error as DatabaseError };
      }

      debugAPI.info(`${table} insertion result`, insertedData);

      // Verify the insertion
      const { exists, data: verifiedData, error: verifyError } = await DatabaseVerificationService.verifyRecord<T>(table, insertedData.id);

      if (!exists || verifyError) {
        const error: DatabaseError = {
          message: 'Verification failed',
          details: verifyError?.message
        };
        debugAPI.error(`${table} verification failed`, error);
        return { data: null, error };
      }

      return { data: verifiedData, error: null };
    } catch (error) {
      const dbError = error as DatabaseError;
      debugAPI.error(`${table} insertion error`, dbError);
      return { data: null, error: dbError };
    }
  }
};

// ===== Authentication Service =====
async function getCurrentUser() {
  debugAPI.step('Authenticating user');
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  
  if (userError) {
    debugAPI.error('Authentication failed', userError);
    throw userError;
  }
  
  if (!user) {
    debugAPI.error('No authenticated user found');
    throw new Error("No authenticated user");
  }
  
  debugAPI.info('User authenticated', { userId: user.id });
  return user;
}

// ===== Database Service =====
async function verifyTableExists(tableName: string): Promise<void> {
  debugAPI.step(`Verifying ${tableName} table exists`);
  
  try {
    const { error } = await supabase
      .from(tableName)
      .select("id")
      .limit(1);
      
    if (error) {
      debugAPI.error('Table verification failed', error);
      throw new Error(`The ${tableName} table is not accessible: ${error.message}`);
    }
  } catch (error) {
    debugAPI.error('Table verification error', error);
    throw new Error(`Failed to verify ${tableName} table: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Checks if the table has the expected columns and structure
 */
async function checkTableStructure(tableName: string): Promise<void> {
  debugAPI.step(`Checking structure of ${tableName} table`);
  
  try {
    // First make sure we can access the table
    const { error: accessError } = await supabase
      .from(tableName)
      .select('*')
      .limit(1);
      
    if (accessError) {
      if (accessError.code === '42P01') { // Table doesn't exist
        debugAPI.error(`Table ${tableName} does not exist`, accessError);
        
        // We could attempt to create it here
        debugAPI.info(`Attempting to create ${tableName} table`);
        // This would need admin privileges - usually done in migrations
      } else {
        debugAPI.error(`Error accessing ${tableName}`, accessError);
      }
      return;
    }
    
    // If we can access it, the table exists at least
    debugAPI.info(`Table ${tableName} exists and is accessible`);
  } catch (error) {
    debugAPI.error(`Table structure check failed for ${tableName}`, error);
  }
}

// Update the insertFileRecord function to use debugAPI
const insertFileRecord = async (fileData: AssignmentFile): Promise<AssignmentFile> => {
  debugAPI.step('Starting file record insertion process', fileData);

  // Check current record count for debugging
  const beforeCount = await DatabaseVerificationService.countRecords('assignment_files');
  debugAPI.info('Records before insertion', { count: beforeCount });

  const { data, error } = await DatabaseService.insertRecord<AssignmentFile>('assignment_files', fileData);

  if (error) {
    throw error;
  }

  // Check record count after insertion
  const afterCount = await DatabaseVerificationService.countRecords('assignment_files');
  debugAPI.info('Records after insertion', { count: afterCount, difference: afterCount - beforeCount });

  if (!data) {
    throw new Error('File record insertion failed - no data returned');
  }

  debugAPI.info('File record insertion completed', { id: data.id });
  return data;
};

// ===== Storage Service =====
async function uploadFileToStorage(file: File, bucketName = "assignments"): Promise<string> {
  // Generate unique filename
  const fileExt = file.name.split(".").pop() || '';
  const fileName = `${crypto.randomUUID()}.${fileExt}`;
  
  debugAPI.step('Uploading to storage', { 
    fileName, 
    fileSize: file.size, 
    fileType: file.type 
  });

  const { error: uploadError } = await supabase.storage
    .from(bucketName)
    .upload(fileName, file);

  if (uploadError) {
    debugAPI.error('Storage upload failed', uploadError);
    throw uploadError;
  }
  
  debugAPI.info('File uploaded successfully');
  return fileName;
}

async function getPublicFileUrl(filePath: string, bucketName = "assignments"): Promise<string> {
  debugAPI.step('Generating public URL');
  const { data: { publicUrl } } = supabase.storage
    .from(bucketName)
    .getPublicUrl(filePath);
  
  debugAPI.info('Public URL generated', { publicUrl });
  return publicUrl;
}

async function deleteFileFromStorage(filePath: string, bucketName = "assignments"): Promise<void> {
  debugAPI.step('Deleting from storage', { filePath });
  
  const { error: storageError } = await supabase.storage
    .from(bucketName)
    .remove([filePath]);

  if (storageError) {
    debugAPI.error('Storage deletion failed', storageError);
    throw storageError;
  }
  
  debugAPI.info('File deleted from storage');
}

// ===== Create File Record =====
function createFileRecord(
  userId: string, 
  assignmentId: string | undefined, 
  fileName: string, 
  fileUrl: string, 
  fileType: string, 
  fileSize: number
): NewAssignmentFile {
  return {
    student_id: userId,
    assignment_id: assignmentId || null,
    file_url: fileUrl,
    file_name: fileName,
    file_type: getFileTypeCategory(fileType),
    file_size: fileSize,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  };
}

// ===== Main File Upload Function =====
export async function handleFileUpload(files: FileList, assignment_id?: string): Promise<AssignmentFile[]> {
  debugAPI.step('Starting file upload process', { 
    filesCount: files.length, 
    assignment_id 
  });
  
  // Get and verify user
  const user = await getCurrentUser();
  
  // Verify table exists
  await verifyTableExists("assignment_files");
  
  const uploadedFiles: AssignmentFile[] = [];
  
  // Process each file
  for (const file of Array.from(files)) {
    let filePath = "";
    
    try {
      // 1. Upload file to storage
      filePath = await uploadFileToStorage(file);
      
      // 2. Get public URL
      const publicUrl = await getPublicFileUrl(filePath);
      
      // 3. Create file record
      const fileRecord = createFileRecord(
        user.id, 
        assignment_id, 
        file.name, 
        publicUrl, 
        file.type, 
        file.size
      );
      
      // 4. Insert into database
      try {
        const fileData = await insertFileRecord(fileRecord);
        uploadedFiles.push(fileData);
      } catch (dbError) {
        // Clean up storage file if database insert fails
        await deleteFileFromStorage(filePath);
        throw dbError;
      }
      
    } catch (error) {
      debugAPI.error('File processing failed', error);
      throw error;
    }
  }

  debugAPI.step('Upload process completed', { 
    filesProcessed: uploadedFiles.length 
  });
  return uploadedFiles;
}

export async function getAssignmentFiles(assignment_id: string): Promise<AssignmentFile[]> {
  try {
    debugAPI.step('Starting file retrieval', { assignment_id });
    
    // Get current user for debugging
    const user = await getCurrentUser();
    
    debugAPI.step('Querying assignment files');
    const { data, error } = await supabase
      .from("assignment_files")
      .select("*")
      .eq("assignment_id", assignment_id)
      .order("created_at", { ascending: false });

    if (error) {
      debugAPI.error('File query failed', error);
      throw error;
    }

    debugAPI.info('Files retrieved successfully', { 
      fileCount: data?.length,
      files: data 
    });
    
    return data as AssignmentFile[];
  } catch (error) {
    debugAPI.error('File retrieval failed', error);
    throw error;
  }
}

export async function deleteAssignmentFile(fileId: string, fileUrl: string): Promise<void> {
  try {
    debugAPI.step('Starting file deletion', { fileId, fileUrl });
    
    // 1. Delete from storage
    const filePath = fileUrl.split("/").pop(); // Get filename from URL
    if (filePath) {
      await deleteFileFromStorage(filePath);
    }

    // 2. Delete from assignment_files table
    debugAPI.step('Deleting database record', { fileId });
    const { error: dbError } = await supabase
      .from("assignment_files")
      .delete()
      .eq("id", fileId);

    if (dbError) {
      debugAPI.error('Database record deletion failed', dbError);
      throw dbError;
    }

    debugAPI.info('File record deleted successfully');
    debugAPI.step('Deletion process completed');
    
  } catch (error) {
    debugAPI.error('File deletion failed', error);
    throw error;
  }
}

export async function diagnoseTableIssues(): Promise<void> {
  try {
    debugAPI.step('Diagnosing potential table issues');
    
    // 1. Check if tables exist and are accessible
    await checkTableStructure('assignment_files');
    
    // 2. Check for RLS policies
    debugAPI.step('Checking for RLS policies');
    
    // Get current user
    const user = await getCurrentUser();
    
    // Try to query directly (will be affected by RLS)
    const { data: rlsData, error: rlsError } = await supabase
      .from('assignment_files')
      .select('*');
      
    if (rlsError) {
      debugAPI.error('RLS may be preventing data access', rlsError);
    } else {
      debugAPI.info('RLS check results', { 
        recordCount: rlsData?.length || 0,
        userId: user.id
      });
    }
    
    // 3. Try a different query approach
    const { data: countData } = await supabase
      .from('assignment_files')
      .select('*', { count: 'exact' });
      
    debugAPI.info('Total records', { count: countData?.length || 0 });
    
    // 4. Get latest record
    const { data: latestData } = await supabase
      .from('assignment_files')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(1);
      
    if (latestData && latestData.length > 0) {
      debugAPI.info('Latest record found', latestData[0]);
    } else {
      debugAPI.warn('No records found in latest query');
    }
      
  } catch (error) {
    debugAPI.error('Diagnostics failed', error);
  }
} 