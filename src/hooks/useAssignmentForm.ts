import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { User } from "@supabase/supabase-js";
import { type AssignmentFormValues, assignmentFormSchema, baseAssignmentFormSchema } from "@/lib/validations/assignment";
import { type AssignmentStep } from "@/types/assignment";
import { ASSIGNMENT_STATUS } from "@/constants/assignment-status";
import { STEPS } from "@/lib/config/steps";
import { ToastService } from "@/lib/services/toast.service";
import { StepService } from "@/lib/services/step.service";
import { getDefaultValues } from "@/lib/services/assignment-defaults.service";
import { ROUTES } from "@/config/routes";
import { 
  createAssignment, 
  updateAssignment, 
  getAssignmentWithFiles,
  deleteAssignment 
} from "@/lib/api/assignments";

/**
 * Constants for the hook configuration
 */
const AUTO_SAVE_DELAY = 1000; // Delay in milliseconds for auto-save debounce

/**
 * Custom hook for managing assignment form state and operations
 * @param {Object} params - Hook parameters
 * @param {User} params.user - The authenticated user object from Supabase
 * @returns {Object} - Form utilities and state management functions
 */
export function useAssignmentForm({ user }: { user: User }) {
  // Hooks and services initialization
  const { id: assignmentId } = useParams<{ id?: string }>();
  const navigate = useNavigate();
  const toast = useMemo(() => new ToastService(), []);
  const steps = useMemo(() => new StepService(STEPS), []);

  // Form state management using react-hook-form
  const form = useForm<AssignmentFormValues>({
    resolver: zodResolver(assignmentFormSchema),
    defaultValues: getDefaultValues(),
    mode: "onChange",
  });

  // Local state variables
  const [currentStep, setCurrentStepState] = useState<AssignmentStep>("basic-info");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [initialFormState, setInitialFormState] = useState<string | null>(null);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  const [autoSaveInProgress, setAutoSaveInProgress] = useState<boolean>(false);

  // Derived state
  const isEditing = !!assignmentId && assignmentId !== ":id";

  /* ==================== Utility Functions ==================== */

  /**
   * Checks if the form data has been modified since initial load
   * @param {AssignmentFormValues} currentData - Current form values
   * @returns {boolean} - True if form has been modified
   */
  const isFormModified = useCallback((currentData: AssignmentFormValues): boolean => {
    return initialFormState !== null && initialFormState !== JSON.stringify(currentData);
  }, [initialFormState]);

  /**
   * Stores the initial form state for comparison
   * @param {AssignmentFormValues} data - Form values to store
   */
  const storeInitialState = useCallback((data: AssignmentFormValues): void => {
    setInitialFormState(JSON.stringify(data));
  }, []);

  /* ==================== Assignment CRUD Operations ==================== */

  /**
   * Creates a new assignment in the database
   * @returns {Promise<AssignmentFormValues>} - The created assignment data
   * @throws {Error} - If creation fails
   */
  const handleCreateAssignment = useCallback(async (): Promise<AssignmentFormValues> => {
    const initialData: AssignmentFormValues = {
      grade: user.user_metadata.grade,
      ...getDefaultValues(),
      student_id: user.id,
      status: ASSIGNMENT_STATUS.DRAFT,
    };
    
    // Remove ID for creation (will be generated by Supabase)
    const { id, ...dataWithoutId } = initialData;
    const newAssignment = await createAssignment(dataWithoutId);
    
    if (!newAssignment?.id) {
      throw new Error("Failed to create assignment - no ID returned");
    }
    
    // Update URL with new assignment ID
    navigate(ROUTES.STUDENT.MANAGE_ASSIGNMENT.replace(":id?", newAssignment.id), { replace: true });
    return { ...initialData, id: newAssignment.id };
  }, [user.user_metadata.grade, user.id, navigate]);

  /**
   * Loads an existing assignment from the database
   * @param {string} id - Assignment ID to load
   * @returns {Promise<AssignmentFormValues | null>} - The loaded assignment data or null if not found
   */
  const handleLoadAssignment = useCallback(async (id: string): Promise<AssignmentFormValues | null> => {
    const assignment = await getAssignmentWithFiles(id);
    
    if (!assignment) {
      toast.error("Assignment not found");
      navigate(ROUTES.STUDENT.DASHBOARD);
      return null;
    }
    
    return assignment;
  }, [toast, navigate]);

  /**
   * Performs an immediate save of assignment data
   * @param {string} id - Assignment ID to update
   * @param {AssignmentFormValues} data - Updated assignment data
   */
  const handleAutoSave = useCallback(async (id: string, data: AssignmentFormValues): Promise<void> => {
    if (autoSaveInProgress || !isFormModified(data)) return;

    setAutoSaveInProgress(true);
    try {
      // Exclude files from the update data
      const { files, ...dataWithoutFiles } = data;
      await updateAssignment(id, { 
        ...dataWithoutFiles, 
        updated_at: new Date().toISOString() 
      });
      storeInitialState(data);
    } catch (error) {
      toast.error("Failed to auto-save changes");
    } finally {
      setAutoSaveInProgress(false);
    }
  }, [autoSaveInProgress, isFormModified, storeInitialState, toast]);

  /**
   * Debounced version of auto-save to prevent rapid successive saves
   * @param {string} id - Assignment ID to update
   * @param {AssignmentFormValues} data - Updated assignment data
   */
  const debouncedAutoSave = useCallback(async (id: string, data: AssignmentFormValues): Promise<void> => {
    if (!isFormModified(data)) return;

    // Clear any pending auto-save
    if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
    
    // Set new timeout for auto-save
    const timeout = setTimeout(async () => {
      await handleAutoSave(id, data);
      setAutoSaveTimeout(null);
    }, AUTO_SAVE_DELAY);
    
    setAutoSaveTimeout(timeout);
  }, [autoSaveTimeout, isFormModified, handleAutoSave]);

  /* ==================== Effects ==================== */

  // Initial data loading effect
  useEffect(() => {
    const loadData = async () => {
      if (!user.id) {
        toast.error("User not authenticated");
        navigate("/login");
        return;
      }

      setIsLoading(true);
      const loadingId = toast.loading(isEditing ? "Loading assignment..." : "Creating assignment...");

      try {
        let assignmentData: AssignmentFormValues | null = null;
        
        if (isEditing) {
          assignmentData = await handleLoadAssignment(assignmentId);
        } else {
          assignmentData = await handleCreateAssignment();
        }

        if (assignmentData) {
          // Reset form with loaded/created data
          form.reset(baseAssignmentFormSchema.parse(assignmentData), { keepDirty: false });
          
          // Mark all steps as visited (for UI purposes)
          STEPS.forEach(step => steps.markStepVisited(step.id));
          
          // If assignment is submitted, jump to feedback step
          if (assignmentData.status === ASSIGNMENT_STATUS.SUBMITTED) {
            setCurrentStepState('teacher-feedback');
          }
          
          // Store initial state for modification detection
          storeInitialState(assignmentData);
        }
      } catch (error) {
        toast.error(error instanceof Error ? error.message : "Failed to load assignment");
      } finally {
        setIsLoading(false);
        toast.dismiss(loadingId);
      }
    };

    loadData();
  }, [assignmentId, form, isEditing, steps, toast, user.id, handleCreateAssignment, handleLoadAssignment, storeInitialState, navigate]);

  // Auto-save effect (watches form changes)
  useEffect(() => {
    const subscription = form.watch((data) => {
      if (!data?.id || isLoading || !steps.isStepEditable(currentStep, data)) return;
      debouncedAutoSave(data.id, data).catch(error => 
        toast.error("Auto-save failed: " + (error instanceof Error ? error.message : "Unknown error"))
      );
    });
    
    return () => {
      subscription.unsubscribe();
      if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
    };
  }, [form, toast, isLoading, currentStep, steps, debouncedAutoSave, autoSaveTimeout]);

  /* ==================== Step Navigation Functions ==================== */

  /**
   * Checks if the current step is complete
   * @returns {boolean} - True if current step is valid
   */
  const isCurrentStepComplete = useCallback((): boolean => {
    const data = form.getValues();
    return currentStep === 'review-submit'
      ? STEPS.every(step => step.id === 'teacher-feedback' || steps.validateStep(step.id, data))
      : steps.validateStep(currentStep, data);
  }, [currentStep, form, steps]);

  /**
   * Checks if the current step is editable
   * @returns {boolean} - True if current step can be edited
   */
  const isCurrentStepEditable = useCallback((): boolean => (
    steps.isStepEditable(currentStep, form.getValues())
  ), [currentStep, form, steps]);

  /**
   * Validates a specific step
   * @param {AssignmentStep} stepId - Step to validate
   * @returns {boolean} - True if step is valid
   */
  const validateStep = useCallback((stepId: AssignmentStep): boolean => (
    steps.validateStep(stepId, form.getValues())
  ), [form, steps]);

  /**
   * Navigates to a specific step if allowed
   * @param {AssignmentStep} step - Target step to navigate to
   */
  const setCurrentStep = useCallback((step: AssignmentStep): void => {
    const data = form.getValues();
    if (steps.canNavigateToStep(step, currentStep, data)) {
      setCurrentStepState(step);
    } else {
      toast.error(`Cannot navigate to '${step}' until all previous steps are complete`);
    }
  }, [currentStep, form, steps, toast]);

  /* ==================== Form Submission Handlers ==================== */

  /**
   * Handles final assignment submission
   * @param {AssignmentFormValues} data - Complete assignment data
   */
  const handleSubmitAssignment = useCallback(async (data: AssignmentFormValues): Promise<void> => {
    if (!data.id) throw new Error("Assignment ID required for submission");
    
    // Update form state to "submitted"
    form.setValue("status", ASSIGNMENT_STATUS.SUBMITTED, { shouldValidate: true });
    const submissionData = { 
      ...data, 
      status: ASSIGNMENT_STATUS.SUBMITTED,
      submitted_at: new Date().toISOString()
    };
    
    await updateAssignment(data.id, submissionData);
    setCurrentStepState('teacher-feedback');
    toast.success("Assignment submitted successfully");
  }, [form, toast]);

  /**
   * Primary save handler - saves current progress and moves to next step
   */
  const handleSaveAndContinue = useCallback(async (): Promise<void> => {
    const data = form.getValues();
    const allPreviousStepsComplete = STEPS
      .slice(0, STEPS.findIndex(step => step.id === currentStep) + 1)
      .every(step => steps.validateStep(step.id, data));

    if (!allPreviousStepsComplete) {
      const invalidSteps = STEPS
        .slice(0, STEPS.findIndex(step => step.id === currentStep) + 1)
        .filter(step => !steps.validateStep(step.id, data))
        .map(step => `'${step.id}'`)
        .join(", ");
      toast.error(`Please complete: ${invalidSteps}`);
      return;
    }

    setIsLoading(true);
    try {
      if (currentStep === "review-submit") {
        await handleSubmitAssignment(data);
      } else {
        if (data.id) await debouncedAutoSave(data.id, data);
        const next = steps.getNext(currentStep, data);
        if (next) {
          steps.markStepVisited(next);
          setCurrentStepState(next);
          toast.success("Saved and continued");
        }
      }
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to save and continue");
    } finally {
      setIsLoading(false);
    }
  }, [currentStep, form, steps, debouncedAutoSave, toast, handleSubmitAssignment]);

  /**
   * Navigates to the previous step if allowed
   */
  const previousStep = useCallback((): void => {
    const data = form.getValues();
    const prev = steps.getPrevious(currentStep, data);
    if (prev) {
      setCurrentStepState(prev);
    } else {
      toast.error("Cannot move back until previous steps are complete");
    }
  }, [currentStep, steps, toast, form]);

  /**
   * Deletes the current assignment
   */
  const handleDeleteAssignment = useCallback(async (): Promise<void> => {
    if (!assignmentId) return;

    setIsLoading(true);
    try {
      await deleteAssignment(assignmentId);
      toast.success("Assignment deleted successfully");
      navigate(ROUTES.STUDENT.DASHBOARD);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to delete assignment");
    } finally {
      setIsLoading(false);
    }
  }, [assignmentId, navigate, toast]);

  // Return all necessary values and functions for component consumption
  return {
    form,
    currentStep,
    setCurrentStep,
    handleSaveAndContinue,
    previousStep,
    isCurrentStepComplete,
    isCurrentStepEditable,
    validateStep,
    isLoading,
    isEditing,
    handleDeleteAssignment,
  };
}