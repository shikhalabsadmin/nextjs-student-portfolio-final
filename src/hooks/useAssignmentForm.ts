import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { User } from "@supabase/supabase-js";
import { type AssignmentFormValues, assignmentFormSchema, baseAssignmentFormSchema } from "@/lib/validations/assignment";
import { type AssignmentStep } from "@/types/assignment";
import { ASSIGNMENT_STATUS } from "@/constants/assignment-status";
import { STEPS } from "@/lib/config/steps";
import { ToastService } from "@/lib/services/toast.service";
import { StepService } from "@/lib/services/step.service";
import { getDefaultValues } from "@/lib/services/assignment-defaults.service";
import { ROUTES } from "@/config/routes";
import { 
  createAssignment, 
  updateAssignment, 
  getAssignmentWithFiles,
  deleteAssignment 
} from "@/lib/api/assignments";

/**
 * Constants for the hook configuration
 */
const AUTO_SAVE_DELAY = 1000; // Delay in milliseconds for auto-save debounce

/**
 * Custom hook for managing assignment form state and operations
 * @param {Object} params - Hook parameters
 * @param {User} params.user - The authenticated user object from Supabase
 * @returns {Object} - Form utilities and state management functions
 */
export function useAssignmentForm({ user }: { user: User }) {
  // Hooks and services initialization
  const { id: assignmentId } = useParams<{ id?: string }>();
  const navigate = useNavigate();
  const toast = useMemo(() => new ToastService(), []);
  
  // Initialize step service with caching and optimized validation
  const steps = useMemo(() => new StepService(STEPS), []);

  // Form state management using react-hook-form
  const form = useForm<AssignmentFormValues>({
    resolver: zodResolver(assignmentFormSchema),
    defaultValues: getDefaultValues(),
    mode: "onBlur",
    criteriaMode: "firstError",
    shouldFocusError: true,
  });

  // Local state variables
  const [currentStep, setCurrentStepState] = useState<AssignmentStep>("basic-info");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [initialFormState, setInitialFormState] = useState<string | null>(null);
  const [autoSaveTimeout, setAutoSaveTimeout] = useState<NodeJS.Timeout | null>(null);
  const [autoSaveInProgress, setAutoSaveInProgress] = useState<boolean>(false);
  const [formDataVersion, setFormDataVersion] = useState(0);

  // Derived state
  const isEditing = !!assignmentId && assignmentId !== ":id";

  /* ==================== Utility Functions ==================== */

  /**
   * Checks if the form data has been modified since initial load
   * @param {AssignmentFormValues} currentData - Current form values
   * @returns {boolean} - True if form has been modified
   */
  const isFormModified = useCallback((currentData: AssignmentFormValues): boolean => {
    return Boolean(initialFormState && initialFormState !== JSON.stringify(currentData));
  }, [initialFormState]);

  /**
   * Stores the initial form state for comparison
   * @param {AssignmentFormValues} data - Form values to store
   */
  const storeInitialState = useCallback((data: AssignmentFormValues): void => {
    setInitialFormState(JSON.stringify(data));
  }, []);

  /* ==================== Assignment CRUD Operations ==================== */

  /**
   * Creates a new assignment in the database
   * @returns {Promise<AssignmentFormValues>} - The created assignment data
   * @throws {Error} - If creation fails
   */
  const handleCreateAssignment = useCallback(async (): Promise<AssignmentFormValues> => {
    const initialData: AssignmentFormValues = {
      grade: user.user_metadata.grade,
      ...getDefaultValues(),
      student_id: user.id,
      status: ASSIGNMENT_STATUS.DRAFT,
    };
    
    // Remove ID for creation (will be generated by Supabase)
    const { id, ...dataWithoutId } = initialData;
    const newAssignment = await createAssignment(dataWithoutId);
    
    if (!newAssignment?.id) {
      throw new Error("Failed to create assignment - no ID returned");
    }
    
    // Update URL with new assignment ID
    const newPath = ROUTES.STUDENT.MANAGE_ASSIGNMENT.replace(":id?", newAssignment.id);
    navigate(newPath, { replace: true });
    return { ...initialData, id: newAssignment.id };
  }, [user.user_metadata.grade, user.id, navigate]);

  /**
   * Loads an existing assignment from the database
   * @param {string} id - Assignment ID to load
   * @returns {Promise<AssignmentFormValues | null>} - The loaded assignment data or null if not found
   */
  const handleLoadAssignment = useCallback(async (id: string): Promise<AssignmentFormValues | null> => {
    const assignment = await getAssignmentWithFiles(id);
    
    if (!assignment) {
      toast.error("Assignment not found");
      navigate(ROUTES.STUDENT.DASHBOARD);
      return null;
    }
    
    return assignment;
  }, [toast, navigate]);

  /**
   * Performs an immediate save of assignment data
   * @param {string} id - Assignment ID to update
   * @param {AssignmentFormValues} data - Updated assignment data
   */
  const handleAutoSave = useCallback(async (id: string, data: AssignmentFormValues): Promise<void> => {
    if (autoSaveInProgress || !isFormModified(data)) return;

    setAutoSaveInProgress(true);
    try {
      // Exclude files from the update data
      const { files, ...dataWithoutFiles } = data;
      await updateAssignment(id, { 
        ...dataWithoutFiles, 
        updated_at: new Date().toISOString() 
      });
      storeInitialState(data);
      
      // Clear validation cache to ensure fresh validation after save
      steps.invalidateCache(currentStep);
    } catch (error) {
      toast.error("Failed to auto-save changes");
      throw error; // Re-throw for caller handling
    } finally {
      setAutoSaveInProgress(false);
    }
  }, [autoSaveInProgress, isFormModified, storeInitialState, toast, steps, currentStep]);

  /**
   * Debounced version of auto-save to prevent rapid successive saves
   * @param {string} id - Assignment ID to update
   * @param {AssignmentFormValues} data - Updated assignment data
   */
  const debouncedAutoSave = useCallback(async (id: string, data: AssignmentFormValues): Promise<void> => {
    if (!isFormModified(data)) return;

    // Clear any pending auto-save
    if (autoSaveTimeout) clearTimeout(autoSaveTimeout);
    
    // Set new timeout for auto-save
    const timeout = setTimeout(async () => {
      try {
        // Get fresh data at time of execution for latest changes
        const currentData = form.getValues();
        await handleAutoSave(id, currentData);
      } catch (error) {
        console.error("Auto-save error:", error);
      } finally {
        setAutoSaveTimeout(null);
      }
    }, AUTO_SAVE_DELAY);
    
    setAutoSaveTimeout(timeout);
  }, [autoSaveTimeout, isFormModified, handleAutoSave, form]);

  /* ==================== Effects ==================== */

  // Initial data loading effect
  useEffect(() => {
    const loadData = async () => {
      if (!user.id) {
        toast.error("User not authenticated");
        navigate("/login");
        return;
      }

      setIsLoading(true);
      const loadingId = toast.loading(isEditing ? "Loading assignment..." : "Creating assignment...");

      try {
        let assignmentData: AssignmentFormValues | null = null;
        
        if (isEditing) {
          assignmentData = await handleLoadAssignment(assignmentId);
        } else {
          assignmentData = await handleCreateAssignment();
        }

        if (assignmentData) {
          // Reset form with loaded/created data
          form.reset(baseAssignmentFormSchema.parse(assignmentData), { keepDirty: false });
          
          // Clear all validation caches to start fresh
          steps.resetStepValidation();
          
          // Mark all steps as visited (for UI purposes)
          STEPS.forEach(step => steps.markStepVisited(step.id));
          
          // If assignment is submitted, jump to feedback step
          if (assignmentData.status === ASSIGNMENT_STATUS.SUBMITTED) {
            setCurrentStepState('teacher-feedback');
          }
          
          // Store initial state for modification detection
          storeInitialState(assignmentData);
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "Failed to load assignment";
        toast.error(message);
      } finally {
        setIsLoading(false);
        toast.dismiss(loadingId);
      }
    };

    loadData();
  }, [assignmentId, form, isEditing, steps, toast, user.id, handleCreateAssignment, handleLoadAssignment, storeInitialState, navigate]);

  // Function to validate only the current step fields
  const validateCurrentStepFields = useCallback(() => {
    const stepConfig = STEPS.find(step => step.id === currentStep);
    if (!stepConfig) return;
    
    // Get validation config for current step
    const data = form.getValues();
    
    // Validate only this step's fields without validating previous steps
    const isValid = steps.validateCurrentStepOnly(currentStep, data);
    
    // Return validation result so we can use it
    return isValid;
  }, [currentStep, form, steps]);

  // Auto-save effect (watches form changes)
  useEffect(() => {
    if (!assignmentId || isLoading) return;
    
    // Define the data change handler
    const handleDataChange = (data: AssignmentFormValues) => {
      if (!data?.id || !steps.isStepEditable(currentStep, data)) return;
      
      // Check validation state to update button status, but without showing errors
      validateCurrentStepFields();
      
      // Force a state update to re-evaluate the button state
      // This is needed because form changes don't automatically trigger button state updates
      setFormDataVersion(prev => prev + 1);
      
      debouncedAutoSave(data.id, data).catch(error => 
        toast.error("Auto-save failed: " + (error instanceof Error ? error.message : "Unknown error"))
      );
    };
    
    // Subscribe to form changes with our handler
    const subscription = form.watch(handleDataChange);
    
    // Clean up function
    return () => {
      subscription.unsubscribe();
      if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
        // Perform one final save if there's a pending auto-save when unmounting
        const currentData = form.getValues();
        if (currentData?.id && isFormModified(currentData)) {
          handleAutoSave(currentData.id, currentData).catch(console.error);
        }
      }
    };
  }, [
    form, 
    toast, 
    isLoading, 
    currentStep, 
    steps, 
    debouncedAutoSave, 
    autoSaveTimeout, 
    assignmentId, 
    isFormModified, 
    handleAutoSave,
    validateCurrentStepFields
  ]);

  // Update validation when step changes
  useEffect(() => {
    // When the current step changes, reset form errors and validate fields
    form.clearErrors();
    validateCurrentStepFields();
  }, [currentStep, validateCurrentStepFields, form]);

  /* ==================== Step Navigation Functions ==================== */

  /**
   * Checks if current step is complete and valid
   * For UI purposes, only validates the current tab's fields
   */
  const isCurrentStepComplete = useCallback((): boolean => {
    const data = form.getValues();
    
    // For UI state in forms, only check the current tab's fields
    return steps.validateCurrentStepOnly(currentStep, data);
  }, [currentStep, form, steps]);

  /**
   * Checks if the current step is editable
   */
  const isCurrentStepEditable = useCallback((): boolean => (
    steps.isStepEditable(currentStep, form.getValues())
  ), [currentStep, form, steps]);

  /**
   * Validates a specific step
   * For progression/navigation, we validate with dependencies
   */
  const validateStep = useCallback((stepId: AssignmentStep): boolean => (
    steps.validateStep(stepId, form.getValues())
  ), [form, steps]);

  /**
   * Navigates to a specific step if allowed
   * Uses the optimized canNavigateToStep which avoids recursive validation
   */
  const setCurrentStep = useCallback((step: AssignmentStep): void => {
    const data = form.getValues();
    if (steps.canNavigateToStep(step, currentStep, data)) {
      setCurrentStepState(step);
      steps.markStepVisited(step);
    } else {
      toast.error(`Cannot navigate to '${step}' until all previous steps are complete`);
    }
  }, [currentStep, form, steps, toast]);

  /* ==================== Form Submission Handlers ==================== */

  /**
   * Handles final assignment submission
   */
  const handleSubmitAssignment = useCallback(async (data: AssignmentFormValues): Promise<void> => {
    if (!data.id) throw new Error("Assignment ID required for submission");
    const {files, ...dataWithoutFiles} = data;
    
    // Update form state to "submitted"
    form.setValue("status", ASSIGNMENT_STATUS.SUBMITTED, { shouldValidate: true });
    const submissionData = { 
      ...dataWithoutFiles, 
      status: ASSIGNMENT_STATUS.SUBMITTED,
      submitted_at: new Date().toISOString()
    };
    
    await updateAssignment(data.id, submissionData);
    setCurrentStepState('teacher-feedback');
    
    // Clear all validation caches after submission
    steps.resetStepValidation();
    
    toast.success("Assignment submitted successfully");
  }, [form, toast, steps]);

  /**
   * Primary save handler - saves current progress and moves to next step
   * Uses optimized step service to avoid redundant validations
   */
  const handleSaveAndContinue = useCallback(async (): Promise<void> => {
    const data = form.getValues();
    
    // Force validation with UI errors when trying to continue
    await form.trigger();
    
    // For tab complete validation, check only the current tab fields
    if (!steps.validateCurrentStepOnly(currentStep, data)) {
      toast.error(`Please complete all required fields in the current step`);
      return;
    }
    
    // When trying to proceed, we need to make sure all previous steps are also valid
    if (currentStep !== 'basic-info' && !steps.validateStep(currentStep, data)) {
      toast.error(`Cannot continue - please complete all previous steps`);
      return;
    }

    setIsLoading(true);
    try {
      if (currentStep === "review-submit") {
        // Handle submission case
        await handleSubmitAssignment(data);
      } else {
        // Regular step progression
        if (data.id) {
          // Clear any pending auto-saves
          if (autoSaveTimeout) {
            clearTimeout(autoSaveTimeout);
            setAutoSaveTimeout(null);
          }
          
          try {
            // Save immediately and wait for result
            await handleAutoSave(data.id, data);
            
            // Only proceed to next step if save was successful
            const next = steps.getNext(currentStep, data);
            if (next) {
              steps.markStepVisited(next);
              setCurrentStepState(next);
              toast.success("Saved and continued");
            }
          } catch (error) {
            // If save fails, show error but don't advance
            toast.error("Failed to save: " + (error instanceof Error ? error.message : "Unknown error"));
            return;
          }
        }
      }
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to save and continue");
    } finally {
      setIsLoading(false);
    }
  }, [currentStep, form, steps, autoSaveTimeout, handleAutoSave, toast, handleSubmitAssignment]);

  /**
   * Navigates to the previous step if allowed
   * Uses optimized step service navigation
   */
  const previousStep = useCallback((): void => {
    const data = form.getValues();
    const prev = steps.getPrevious(currentStep, data);
    if (prev) {
      setCurrentStepState(prev);
    } else {
      toast.error("Cannot navigate back from this step");
    }
  }, [currentStep, steps, toast, form]);

  /**
   * Deletes the current assignment
   */
  const handleDeleteAssignment = useCallback(async (): Promise<void> => {
    if (!assignmentId) return;

    setIsLoading(true);
    try {
      await deleteAssignment(assignmentId);
      toast.success("Assignment deleted successfully");
      navigate(ROUTES.STUDENT.DASHBOARD);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to delete assignment");
    } finally {
      setIsLoading(false);
    }
  }, [assignmentId, navigate, toast]);

  // Calculate if continue button should be disabled - using tab-only validation
  const isContinueDisabled = useMemo(() => {
    // Get current form data
    const data = form.getValues();
    
    // For button state, only validate the current tab's fields
    // Include formDataVersion in dependencies to ensure this recalculates when form data changes
    const stepIsComplete = steps.validateCurrentStepOnly(currentStep, data);
    const stepIsEditable = steps.isStepEditable(currentStep, data);
    
    // Log for debugging only in development
    if (process.env.NODE_ENV === 'development') {
      console.log('Button state check:', { 
        isLoading, 
        stepComplete: stepIsComplete, 
        stepEditable: stepIsEditable,
        dataVersion: formDataVersion
      });
    }
    
    return isLoading || !stepIsComplete || !stepIsEditable;
  }, [isLoading, currentStep, form, steps, formDataVersion]);

  // Return all necessary values and functions for component consumption
  return {
    form,
    currentStep,
    setCurrentStep,
    handleSaveAndContinue,
    previousStep,
    isCurrentStepComplete,
    isCurrentStepEditable,
    validateStep,
    isLoading,
    isEditing,
    handleDeleteAssignment,
    isContinueDisabled,
  };
}